@startuml
namespace peers {
	class peers.PeerRoutine << (T, #FF7700) >> {
	}
	class "<font color=blue>func</font>(c *comms.UDPCommunication, wg *sync.WaitGroup, shutdown <font color=blue>chan</font> <font color=blue>struct</font>{}) " as peers.funcccommsUDPCommunicationwgsyncWaitGroupshutdownchanstruct {
	}
	"peers.funcccommsUDPCommunicationwgsyncWaitGroupshutdownchanstruct" #.. "PeerRoutine"
	class peers.PeersGlobal << (G,Green) >> {
		- snipMux sync.Mutex
		- peerMux sync.Mutex
	
		+ PEER_TIMEOUT 
		+ PeerRoutines 
		+ OPTIONS 
		+ SNIPPET_SHUTDOWN_MSG 
		+ REFRESH_RATE time.Duration
		+ REQUEST_LENGTH 
		+ STOP_REQUEST 
		+ SNIP_REQUEST 
		+ PEER_REQUEST 
		+ SEND_INTERVAL 
	
		+ InputChannel(scanner *bufio.Scanner, input chan struct{})
		+ SnippetDisplayRoutine(cont chan struct{}, stop chan struct{})
		+ SnippetUIRoutine(c *comms.UDPCommunication, wg *sync.WaitGroup, shutdown chan struct{})
		+ StopHandler(p *comms.Packet)
		+ SnipHandler(p *comms.Packet)
		+ PeerHandler(p *comms.Packet)
		+ SendPeersRoutine(c *comms.UDPCommunication, wg *sync.WaitGroup, shutdown chan struct{})
		+ PeerRoutinesManager(c *comms.UDPCommunication)
		+ SendSnippetRoutine(c *comms.UDPCommunication, wg *sync.WaitGroup, snippet collection.Snippet)
		+ PeersHandlerRoutine(c *comms.UDPCommunication, wg *sync.WaitGroup, shutdown chan struct{})
		+ Clear()
	}
	class peers.PeersHandler << (T, #FF7700) >> {
	}
	class "<font color=blue>func</font>(*comms.Packet) " as peers.funccommsPacket {
	}
	"peers.funccommsPacket" #.. "PeersHandler"
	
}

namespace registry {
	class registry.RegistryRequestHandler << (T, #FF7700) >> {
	}
	class "<font color=blue>func</font>(*comms.TCPCommunication) error " as registry.funccommsTCPCommunicationerror {
	}
	"registry.funccommsTCPCommunicationerror" #.. "RegistryRequestHandler"
	class registry.RegistryGlobal << (G,Green) >> {
		+ LOCATION_REQUEST 
		+ TEAM_NAME_REQUEST 
		+ CODE_REQUEST 
		+ RECEIVE_REQUEST 
		+ REPORT_REQUEST 
		+ CLOSE_REQUEST 
	
		+ CodeHandler(c *comms.TCPCommunication) error
		+ ReceiveHandler(c *comms.TCPCommunication) error
		+ ReportHandler(c *comms.TCPCommunication) error
		+ CloseHandler(c *comms.TCPCommunication) error
		+ RegistryHandlerRoutine(c *comms.TCPCommunication) error
		+ LocationHandler(c *comms.TCPCommunication) error
		+ TeamNameHandler(c *comms.TCPCommunication) error
	}
	
}

namespace collection {
	class collection.Collection << (T, #FF7700) >> {
		- sources []Source
		- snippets []Snippet
		- code []byte
		- shutdown chanstruct{}
		- peersUDP []PeerUDP
		- lamport int
		- peers map[string]time.Time
		- sentPeers []PeerUDP
		- location string
	
	
		- dumpCollection()
		- updateLamport(timestamp int)
		- incrementLamport()
	
		+ Peers() map[string]time.Time
		+ Shutdown() chan struct{}
		+ AddSnippet(snippet Snippet)
		+ CreateSnippet(content string) Snippet
		+ Lamport() int
		+ Sources() []Source
		+ AddPeerUDP(sourceAddr, peerAddr string)
		+ AddSentPeer(peerUDP PeerUDP)
		+ AddPeer(peer string, t time.Time)
		+ AddSource(addr string, peers []string)
		+ PeersUDP() []PeerUDP
		+ Code() ([]byte, error)
		+ SetShutdown()
		+ ActivePeers(timeout int) []string
		+ Snippets() []Snippet
		+ SentPeers() []PeerUDP
		+ Location() string
		+ AddPeers(peers []string, t time.Time)
		+ SetLocation(address string)
		+ UpdatePeerTime(peer string, t time.Time)
	}
	class collection.CollectionGlobal << (G,Green) >> {
		+ TEAM_NAME 
		+ EXTENSION 
	
		+ Init() *Collection
	}
	class collection.Dump << (S,Aquamarine) >> {
		+ Snippets []Snippet
		+ Lamport int
		+ Location string
		+ Peers map[string]time.Time
		+ Sources []Source
		+ PeersUDP []PeerUDP
		+ SentPeers []PeerUDP
	}
	class collection.Snippet << (S,Aquamarine) >> {
		+ SourceAddress string
		+ Timestamp int
		+ Content string
		+ Date string
	}
	class collection.Source << (S,Aquamarine) >> {
		+ Address string
		+ Date string
		+ Peers []string
	}
	class collection.PeerUDP << (S,Aquamarine) >> {
		+ SourceAddress string
		+ PeerAddress string
		+ Date string
	}
	
}

namespace comms {
	class comms.TCPCommunication << (S,Aquamarine) >> {
		- reader *bufio.Reader
	
		+ Conn *net.TCPConn
	
		+ ReadLine() (string, error)
		+ Write(data []byte) error
		+ Close() error
	}
	class comms.CommsGlobal << (G,Green) >> {
		+ TCP4 
		+ UDP4 
		+ MAX_PACKET_SIZE 
		+ DEFAULT_TIMEOUT time.Duration
	
		+ IsValidIPv4(hostport string) bool
		+ ConnectTCP(address string) (*TCPCommunication, error)
		+ ListenUDP(address string) (*UDPCommunication, error)
	}
	class comms.Packet << (S,Aquamarine) >> {
		+ Data []byte
		+ Address string
	}
	class comms.UDPCommunication << (S,Aquamarine) >> {
		+ Conn *net.UDPConn
	
		+ ReadFrom() (*Packet, error)
		+ WriteTo(data []byte, address string) error
		+ Close() error
	}
	
}

namespace main {
	class main.MainGlobal << (G,Green) >> {
		+ CSX3_IPV4 
	
		- registryStep() error
		- main()
	}
	
}

namespace util {
	class util.UtilGlobal << (G,Green) >> {
		+ UNKNOWN_FUNC 
		+ Logger *log.Logger
		+ NetLogger *log.Logger
	
		+ Caller(stack int) string
		+ Log(log *log.Logger, v ...interface{})
		+ Date(t time.Time) string
	}
	
}
main.MainGlobal --> collection.CollectionGlobal
collection.Collection --> collection.Dump
collection.Collection --> collection.Source
peers.PeersGlobal --> util.UtilGlobal
peers.PeersGlobal --> comms.UDPCommunication
registry.RegistryGlobal --> collection.CollectionGlobal
main.MainGlobal --> registry.RegistryGlobal
collection.Collection --> collection.PeerUDP
comms.UDPCommunication --> util.UtilGlobal
comms.TCPCommunication --> util.UtilGlobal
peers.PeersGlobal --> comms.CommsGlobal
peers.PeersGlobal --> collection.CollectionGlobal
main.MainGlobal --> util.UtilGlobal
registry.RegistryGlobal --> comms.CommsGlobal
registry.RegistryGlobal --> comms.TCPCommunication
main.MainGlobal --> comms.CommsGlobal
main.MainGlobal --> peers.PeersGlobal
collection.Collection --> util.UtilGlobal
collection.Collection --> collection.Snippet
peers.PeersGlobal --> comms.Packet
peers.PeersGlobal --> collection.Snippet
@enduml
